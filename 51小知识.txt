
keil  c中，系统特殊寄存器组“Sys”中有一项“sec”和“states”，可查看程序执行时间和运行周期数。例如，执行到延时子程序时，记录进入该子程序的sec值，然后按过程单步键，快速执行该子程序完毕，再读取sec值，两者之差，即为该子程序执行时间。也可根据周期数states与图2-8中设置的晶振频率计算程序运行时间。以上摘自张志良编著《80C51单片机实用教程――基于Keil C和Proteus》高等教育出版社ISBN 978-7-04-044532-9, 用于学习51单片机原理，程序（双解c和汇编）语句条条有注解，便于阅读理解，便于自学。



================================================================================
常量可用在不必改变值的场合，如固定的数据表，字库等。常量的定义方式有几种,下
面来加以说明。
#difine False 0x0; //用预定义语句可以定义常量
#difine True 0x1; //这里定义 False 为 0,True 为 1
//在程序中用到 False 编译时自动用 0 替换，同理 True 替换为 1
unsigned int code a=100; //这一句用 code 把 a 定义在程序存储器中并赋值
const unsigned int c=100; //用 const 定义 c 为无符号 int 常量并赋值
以上两句它们的值都保存在程序存储器中，而程序存储器在运行中是不允许被修改的，
所以如果在这两句后面用了类似 a=110， a++这样的赋值语句，编译时将会出错。



=================================================================================================

51单片机中，中断分高低两个优先级，高优先级的中断能打断低优先级的中断。
但同级中断是不能打断同级中断的！无论该中断函数有多长，在执行到一半这个中断又发生了，还是要等到该中断函数执行完毕，并再执行了一条主程序指令后才会再次进入该中断。
不过，若楼主恰好在这个低优先级中断服务程序中修改了该中断为高优先级，那么如果该中断函数比较长，执行到一半又触发了这个中断，则该中断函数就会被重新从头开始执行（中断嵌套）。这是因为除串口中断以外的其他中断，在 CPU 响应该中断，程序转入该中断函数前就已经将该中断的中断标志清零了。
另外，51的串口中断比较特别，因为需要软件清除串口中断标志，所以只要在未清串口中断标志前，是不会发生上述这样的中断嵌套的。

一个正在执行的低优先级中断程序能被高优先级的中断源所中断，但不能被另一个低优先级的中断源所中断。若cpu正在执行高优先级的中断，则不能被任何中断源所中断，一直执行到结束，遇到中断返回指令RETI，返回主程序后再执行一条指令后才能响应新的中断请求（这里的新可以理解为是又一个新的中断，如果是嵌套中断的话就不是新的中断了，而是直接返回中断中继续执行中断）
================================================================================================

复位 RST 9
在振荡器运行时，有两个机器周期（24 个振荡周期）以上的高电平出现在此引腿
时，将使单片机复位，只要这个脚保持高电平， 51 芯片便循环复位。复位后 P0－P3 口
均置 1 引脚表现为高电平，程序计数器和特殊功能寄存器 SFR 全部清零。当复位脚由
高电平变为低电平时，芯片为 ROM 的 00H 处开始运行程序。复位操作不会对内部 RAM 有所影响。

======================================================================================================

要正确地从引脚上读入外部信息，必须先使场效应管关断，以便由外部输入的信息确定引脚的状态。为此，在作引
脚读入前，必须先对该端口写入l。具有这种操作特点的输入/输出端口，称为准双向I/O口。8051单片机的P1、P2、P3都是准双向
口。P0端口由于输出有三态功能，输入前，端口线已处于高阻态，无需先写入l后再作读操作。
P1口的结构相对简单，前面我们已详细的分析了P0口，只要大家认真的分析了P0口的工作原理，P1口我想大家都有能力去分析，
这里我就不多论述了。
单片机复位后，各个端口已自动地被写入了1，此时，可直接作输入操作。如果在应用端口的过程中，已向P1一P3端口线输出过
0，则再要输入时，必须先写1后再读引脚，才能得到正确的信息。

=================================================================================================================
data: 固定指前面0x00-0x7f的128个RAM,可以用acc直接读写的,速度最快,生成的代码也最小。
 bit :是指0x20-0x2f的可位寻址区
idata:固定指前面0x00-0xff的256个RAM,其中前128和dATa的128完全相同,只是因为访问的方式不同。 
idata是用类似C中的指针方式访问的。 
汇编中的语句为：mox ACC,@Rx.(不重要的补充：c中idATa做指针式的访问效果很好)  
xdATa: 外部扩展RAM,一般指外部0x0000-0xffff空间,用DPTR访问。 
pdATa: 外部扩展RAM的低256个字节,地址出现在A0-A7的上时读写,用movx ACC,@Rx读写。这个比较特殊,而且C51好象有对此BUG, 建议少用。



================================================================================================
NaN 0xFFFFFFF 不是一个数
+INF 0x7F80000 正无穷大 正溢出
-INF 0Xff80000 负无穷大 负溢出

union f {
float f; /* Floating-point value */
unsigned long u1; /* Unsigned long value */
};

这个union包含一个float和一个unsigned long 是为了执行浮点算术运算和响应IEEE错
误状态

例如
#define NaN 0xFFFFFFFF /* Not a number (error) */
#define plusINF 0x7F800000 /* Positive overflow */
#define minusINF 0xFF800000 /* Negative overflow */
union f {
float f; /* Floating-point value */
unsigned long ul; /* Unsigned long value */
};
void main (void) {
float a, b;
union f x;
x.f = a * b;
if (x.ul == NaN || x.ul == plusINF || x.ul == minusINF) {
/* handle the error */
}
else {
/* result is correct */
}
}
===================================================================================================


注意
如果用_at_关键词声明一个变量来访问一个 XDATA 外围设备 应使用 volatile 关键词
以确保 C 编译器不进行优化以便能访问到要访问的存储区
在绝对变量定位中有下面限制
1.绝对变量不能初始化
2.bit 类型的函数和变量不能定位到一个绝对地址
下面的例子示范如何用_at_定位几个不同的变量类型

struct link
{
struct link idata *next;
char code *test;
};
struct link list idata _at_ 0x40; /* list at idata 0x40 */
char xdata text[256] _at_ 0xE000; /* array at xdata 0xE000 */
int xdata i1 _at_ 0x8000; /* int at xdata 0x8000 */
void main ( void ) {
link.next = (void *) 0;
i1 = 0x1234;
text [0] = 'a';

可以在一个源代码模块中声明一个变量 而在另一个模块中使用 用下面的外部声
明在另外的源文件中访问上面定义的_at_变量
struct link
{
struct link idata *next;
char code *test;
};
extern struct link idata list; /* list at idata 0x40 */
extern char xdata text[256]; /* array at xdata 0xE000 */
extern int xdata i1; /* int at xdata 0x8000 */

=======================================================================================================

51单片机定时和计数有何不同点和相同点

1.计数功能是对外来脉冲进行计数,一般由T0,T1两个引脚输入,当输入引脚脉冲发生负跳变时,计数器加1.
2.定时功能也是通过计数来完成的,不过此时的计数脉冲来自单片机的内部,也就跟单片机的内部晶振有关.
=================================================================================================

8位自动装载模式。
1、定时最多为256个时钟
给你打个比方：刚开始给TH0，TH0，敷相同一个值
运行的时候只有TL0在定时 TH0值不变。
定时满了后单片机会有溢出，TH0里面的值会自动给TL0，所以不需要重新敷值！

========================================================================================================
串行数据的发送实际上就是靠改变IO口电平来实现的，IO口在同一时间就只能表示两种状态：高低电平，对应数据位0或1．串口第次发送8位数据就是让IO口在发送时间内变化8次．
为什么是8位，因为串口在方式1是以字节为单位发送的．
而为什么串口在方式1要以字节为单位呢？　这是在硬件设计之初就确定好的，是串口标准．你我是不能改变的．
发送时间是由波特率决定的，波特率就是指每秒钟发送多少个bit位．
串口标准中：　要发送一个数据，还得加上一些其它的东西，比如起始位 停止位等．
a=01；SUBF=a；　单片机执行后，就会将a中的8个位送到SUBF缓冲器中，SUBF也是一个字节．　然后单片机将会按设置好的参数启动串口，将SUBF中的数据一位一位的送到IO口上，即TXD引脚上，至于起始位　停止位些是由串口自动实现的，只要设置好后，不需去理会．时间当然也是由波特率决定的．　
综上所述，在使用单片机串口时，波特率的设置是必不可少的．两个设备要通信，他们的波特率　停止位　数据位都是必不可少的．
当接收完一帧数据是，RI=1发出中断请求被响应，SBUF中的数据要及时的取走，否则下次再来的数据就会覆盖掉这次的数据。
=======================================================================================================


模式1和模式3的波特率是可变的，取决于定时器1或2（52芯片）的溢出速率，就是说定时器1每溢出一次，串口发送一次数据


====================================================================================================
















